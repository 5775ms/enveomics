#!/usr/bin/ruby

#
# @author: Luis M. Rodriguez-R
# @update: Oct-31-2014
# @license: artistic license 2.0
#

require 'optparse'

ARGV << '-h' if ARGV.size==0
o = {:q=>FALSE, :f=>"(\\S+)\\.txt", :consolidate=>TRUE, :pre=>[]}
OptionParser.new do |opts|
   opts.banner = "
Annotates Orthology Groups (OGs) using one or more reference genomes.

Usage: #{$0} [options]"
   opts.separator ""
   opts.separator "Mandatory"
   opts.on("-i", "--in FILE", "Input file containing the OGs (as generated by ogs.rb)."){ |v| o[:in]=v }
   opts.on("-o", "--out FILE", "Output file containing the annotated OGs."){ |v| o[:out]=v }
   opts.on("-a FILE1,FILE2,...", Array, "Input file(s) containing the annotations.One or more tab-delimited files",
   		"with the gene names in the first column and the annotation in the second."){ |v| o[:annotations]=v }
   opts.separator ""
   opts.separator "Other Options"
   opts.on("-f","--format STRING", "Format of the filenames for the annotation files, using regex syntax.",
   		"By default: '#{o[:f]}'."){ |v| o[:f]=v }
   opts.on("-q", "--quiet", "Run quietly (no STDERR output)."){ o[:q] = TRUE }
   opts.on("-h", "--help", "Display this screen.") do
      puts opts
      exit
   end
   opts.separator ""
end.parse!
abort "-i is mandatory" if o[:in].nil?
abort "-o is mandatory" if o[:out].nil?
abort "-a is mandatory" if o[:annotations].nil?

##### CLASSES:
# Gene.new(genome, id): Initializes a new Gene.
# genome: A string uniquely identifying the parent genome.
# id: A string uniquely identifying the gene within the genome. It can be non-unique across genomes.
class Gene
   attr_reader :genome_id, :id
   @@genomes = []
   def self.genomes
      @@genomes
   end
   def initialize(genome, id)
      if genome.is_a? Integer
         abort "Internal error: Genome #{genome} does not exist yet." if @@genomes[genome].nil?
	 @genome_id = genome
      else
	 @@genomes << genome unless @@genomes.include? genome
	 @genome_id = @@genomes.index(genome)
      end
      @id = id
   end
   # Compare if two Gene objects refer to the same gene.
   def ==(b)
      self.genome_id==b.genome_id and self.id==b.id
   end
   # Get all genomes in the run as an array of strings.
   def genome
      @@genomes[self.genome_id]
   end
   def to_s
      "#{self.genome}:#{self.id}"
   end
end

# OG.new(): Initializes an empty OG.
# OG.new(genomes, genes): Initializes a pre-computed OG.
# genomes: List of genomes as an array of strings (as in Gene.genomes).
# genes: List of genes as an array of strings, with '-' indicating no genes and multiple genes separated by ','.
class OG
   attr_reader :genes, :notes
   def initialize(genomes=nil, genes=nil)
      @genes = []
      @notes = []
      unless genomes.nil? or genes.nil?
	 (0 .. genes.length-1).each do |genome_i|
	    next if genes[genome_i]=="-"
	    genes[genome_i].split(/,/).each do |gene_id|
	       self << Gene.new(genomes[genome_i], gene_id)
	    end
	 end
      end
   end
   # Add genes or combine another OG into the loaded OG (self).
   def <<(obj)
      if obj.is_a? Gene
	 @genes[obj.genome_id] = [] if @genes[obj.genome_id].nil?
	 @genes[obj.genome_id] << obj.id unless self.include? obj
      elsif obj.is_a? OG
	 obj.genes_obj.each{ |gene| self << gene }
      else
	 abort "Unsupported class for #{obj}"
      end
   end
   # Get the list of genes as objects (internally saved as strings to save RAM).
   def genes_obj
      o = []
      (0 .. Gene.genomes.length-1).map do |genome_id|
         o += self.genes[genome_id].map{ |gene_id| Gene.new(Gene.genomes[genome_id], gene_id) } unless self.genes[genome_id].nil?
      end
      return o
   end
   # Evaluates if the OG contains the passed gene.
   def include?(gene)
      return false if self.genes[gene.genome_id].nil?
      self.genes[gene.genome_id].include? gene.id
   end
   # Adds a note that will be printed after the last column
   def add_note note
      @notes << note
   end
   def to_s
      (0 .. Gene.genomes.length-1).map do |genome_id|
	 self.genes[genome_id].nil? ? "-" : self.genes[genome_id].join(",")
      end.join("\t") + ((self.notes.size==0) ? '' : ("\t"+self.notes.join("\t")))
   end
end

# OGCollection.new(): Initializes an empty collection of OGs.
class OGCollection
   attr_reader :ogs
   def initialize
      @ogs = []
   end
   # Add an OG to the collection
   def <<(og)
      @ogs << og
   end
   # Compare OGs all-vs-all to identify groups that should be merged.
   def consolidate!
      old_ogs = self.ogs
      @ogs = []
      old_ogs.each do |og|
	 is_new = true
	 og.genes_obj.each do |gene|
	    o = self.get_og gene
	    unless $o.nil?
	       o << og
	       is_new = false
	       break
	    end
	 end
	 self << og if is_new
      end
   end
   # Add a pair of RBM genes into the corresponding OG, or create a new OG.
   def add_rbm(a, b)
      og = self.get_og(a)
      og = self.get_og(b) if og.nil?
      if og.nil?
	 og = OG.new
	 @ogs << og
      end
      og << a
      og << b
   end
   # Get the OG containing the gene (returns the first, if multiple).
   def get_og(gene)
      idx = self.ogs.index { |og| og.include? gene }
      idx.nil? ? nil : self.ogs[idx]
   end
   def to_s
      Gene.genomes.join("\t") + "\n" + self.ogs.map{ |og| og.to_s }.join("\n")
   end
end

##### MAIN:
begin
   # Read the pre-computed OGs
   collection = OGCollection.new
   $stderr.puts "Reading pre-computed OGs in '#{o[:in]}'." unless o[:q]
   f = File.open(o[:in], 'r')
   h = f.gets.chomp.split /\t/
   while ln = f.gets
      collection << OG.new(h, ln.chomp.split(/\t/))
   end
   f.close
   $stderr.puts " Loaded OGs: #{collection.ogs.length}." unless o[:q]

   # Read annotations
   o[:annotations].each do |annot|
      m = /#{o[:f]}/.match(annot)
      if m.nil? or m[1].nil?
	 warn "Cannot parse filename: #{rbm_file} (doesn't match /#{o[:f]}/)."
	 next
      end
      f = File.open(annot, 'r')
      no_og = 0
      while ln=f.gets
	 r = ln.chomp.split /\t/
	 g = Gene.new m[1], r[0]
	 og = collection.get_og g
	 if og.nil?
	    no_og += 1
	 else
	    og.add_note g.to_s + '::' + r[1]
	 end
      end
      warn "Warning: Cannot find #{no_og} genes from #{m[1]} in OG collection." if no_og>0
   end 
   # Save the output matrix
   $stderr.puts "Saving annotated OGs into '#{o[:out]}'." unless o[:q]
   f = File.open(o[:out], "w")
   f.puts collection.to_s
   f.close
   $stderr.puts "Done.\n" unless o[:q] 
rescue => err
   $stderr.puts "Exception: #{err}\n\n"
   err.backtrace.each { |l| $stderr.puts l + "\n" }
   err
end


